this 和 self 相同吗？
	并不。
	在python中，self是一个隐式声明的变量，其作用域是class(object) scope。当类实例化进程开始时，会隐式调用new方法，创建一个从基类一路继承到父类的对象实体，并声明一个self变量将该对象赋值给他，随后在对该对象（self变量）进行修饰。
	在c++中，this并不实际是一个变量，或者说不存在this变量。它的机制是，所有类方法会隐式存在一个const class &类型的参数(this的数据类型)，在调用类方法时，编译器会自动将对象的引用传入该参数。重点是，该过程不涉及this 变量的声明。

cpp中不初始化的变量的值是随机的吗？如果是，为什么类成员变量在没有初始化且没有（显式）构造函数时的值是规律的？
	是随机的。
	因为当没有显式编写构造函数时，类实例化会调用默认构造函数并将所有成员变量赋为规律值。

所以把void类型的函数设置为返回object reference 是一种更美观的写法，可以实现连续调用方法。

为什么不能用pointer作为*this返回值类型？
	因为*this返回的是对象而非地址，直接返回this即可

在返回cin object时，返回类型可以是ostream而不是ostream&吗？
	不行。
	因为返回类型是ostream实际上是在全局域声明了一个ostream object并把原cin object的值赋给这个新object，但iostream 库禁止创建新的iostream object，只能从他们的库里引用cin, cout.

cstring的边界不是由'\0'实现的，而是在声明时得到的，编译器知道cstring的（内存）边界在哪，'\0'只不过是给输入输出流对象阅读的标定

functor重构有什么用


dynamic binding 有什么用
在为一系列同基类子类编写一般性函数时，一定要使用基类指针作为参数传入，因此需要使用虚函数


